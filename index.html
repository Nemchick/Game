<html>
  <head>
    <style>
      .container {
        display: flex;
        gap: 20px;
        padding: 20px;
        justify-content: center;
      }

      .field {
        width: 300px;
        height: 300px;
        border: 2px solid #000;
        position: relative;
      }

      .field-a {
        background: #fff3e0;
      }

      .field-b {
        background: #e3f2fd;
      }

      .dot {
        width: 12px;
        height: 12px;
        background: gold;
        border-radius: 50%;
        position: absolute;
        transition: all 0.3s ease;
        user-select: none;
        z-index: 1;
      }

      .dot.draggable {
        cursor: move;
      }

      .dot.dragging {
        opacity: 0.5;
        z-index: 1000;
      }

      .field-b .dot:hover {
        transform: scale(1.2);
      }

      .controls {
        display: flex;
        flex-direction: column;
        gap: 10px;
        min-width: 200px;
      }

      .button {
        padding: 10px;
        cursor: pointer;
        background: #4caf50;
        color: white;
        border: none;
        border-radius: 4px;
        transition: background 0.3s;
      }

      .button:hover {
        background: #45a049;
      }

      .button:disabled {
        background: #cccccc;
        cursor: not-allowed;
      }

      .timer {
        color: #ff0000;
        font-weight: bold;
      }

      @keyframes shuffle {
        0% {
          transform: translate(0, 0);
        }
        50% {
          transform: translate(10px, 10px) rotate(180deg);
        }
        100% {
          transform: translate(0, 0);
        }
      }

      .shuffle {
        animation: shuffle 0.5s ease;
      }

      .colored {
        background: #ff9800;
      }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="field field-a" id="fieldA"></div>
      <div class="field field-b" id="fieldB"></div>

      <div class="controls">
        <label>
          Количество элементов в блоке A:
          <input type="number" id="dotsCountAInput" value="20" min="1" />
        </label>
        <label>
          Количество элементов в блоке B:
          <input type="number" id="dotsCountBInput" value="20" min="1" />
        </label>
        <button class="button" id="generateBtn" onclick="generateDots()">
          Сгенерировать точки
        </button>
        <button class="button" id="colorBtn" onclick="changeColor()">
          Изменить цвет
        </button>
        <button class="button" id="shuffleBtn" onclick="shuffleDots()">
          Перемешать автоматически
        </button>
        <button class="button" id="resetBtn" onclick="resetPositions()">
          Сбросить позиции
        </button>
        <button class="button" id="manualBtn" onclick="enableManualDrag()">
          Перемешать вручную
        </button>
        <div id="timer" class="timer"></div>
      </div>
    </div>

    <script>
      const initialPositions = new Map();
      let dragTimer = null;
      let countdownInterval = null;

      // Конфигурация
      const CONFIG = {
        dotsCountA: 20, // Количество точек в поле A
        dotsCountB: 20, // Количество точек в поле B
        clusterRadius: 50, // Радиус кластера для точек в поле B
        minDistanceA: 30, // Минимальное расстояние между точками в поле A
        minDistanceB: 15, // Минимальное расстояние между точками в поле B
        randomScatterChance: 0.2, // Вероятность "отлета" точки в блоке B
        scatterRadius: 100, // Радиус случайного "отлета" точки в блоке B
      };

      // Таймер для ручного перемешивания
      function startManualTimer() {
        const timerDisplay = document.getElementById("timer");
        let timeRemaining = 60; // Таймер на 60 секунд

        clearInterval(countdownInterval);

        countdownInterval = setInterval(() => {
          timerDisplay.textContent = `Осталось: ${timeRemaining} сек`;
          timeRemaining--;

          if (timeRemaining < 0) {
            clearInterval(countdownInterval);
            timerDisplay.textContent = "Время вышло!";
            disableManualDrag();
          }
        }, 1000);
      }

      // Включение ручного перемешивания
      function enableManualDrag() {
        const dots = document.querySelectorAll(".field-b .dot");

        dots.forEach((dot) => makeDotDraggable(dot));
        startManualTimer();
      }

      function disableManualDrag() {
        const dots = document.querySelectorAll(".field-b .dot");

        dots.forEach((dot) => {
          dot.classList.remove("draggable");
          dot.removeEventListener("mousedown", startDragging);
          dot.removeEventListener("touchstart", startDragging);
        });
      }

      // Проверка, что точки не пересекаются
      function isFarEnough(x, y, positions, minDistance) {
        return positions.every(
          (pos) =>
            Math.sqrt(Math.pow(pos.left - x, 2) + Math.pow(pos.top - y, 2)) >=
            minDistance
        );
      }

      // Генерация случайных точек с проверкой расстояния
      function generateRandomPositions(field, count, minDistance) {
        const positions = [];

        for (let i = 0; i < count; i++) {
          let x, y;
          let attempts = 0;

          do {
            x = Math.random() * (field.offsetWidth - 12);
            y = Math.random() * (field.offsetHeight - 12);
            attempts++;
          } while (
            (!isFarEnough(x, y, positions, minDistance) ||
              x < 0 ||
              y < 0 ||
              x > field.offsetWidth - 12 ||
              y > field.offsetHeight - 12) &&
            attempts < 100
          );

          if (attempts < 100) {
            positions.push({ left: x, top: y });
          }
        }

        return positions;
      }

      // Генерация точек в форме кластера с возможностью "отлета" точек
      function generateClusteredPositions(
        field,
        count,
        clusterRadius,
        minDistance
      ) {
        const positions = [];
        const centerX = field.offsetWidth / 2;
        const centerY = field.offsetHeight / 2;

        for (let i = 0; i < count; i++) {
          let x, y;
          let attempts = 0;

          do {
            const isScatter = Math.random() < CONFIG.randomScatterChance;

            if (isScatter) {
              // Генерация точки за пределами основного кластера
              const angle = Math.random() * 2 * Math.PI;
              const radius = CONFIG.scatterRadius * Math.random();
              x = centerX + radius * Math.cos(angle) - 6;
              y = centerY + radius * Math.sin(angle) - 6;
            } else {
              // Генерация точки внутри основного кластера
              const angle = Math.random() * 2 * Math.PI;
              const radius = Math.random() * clusterRadius;
              x = centerX + radius * Math.cos(angle) - 6;
              y = centerY + radius * Math.sin(angle) - 6;
            }

            attempts++;
          } while (
            (!isFarEnough(x, y, positions, minDistance) ||
              x < 0 ||
              y < 0 ||
              x > field.offsetWidth - 12 ||
              y > field.offsetHeight - 12) &&
            attempts < 100
          );

          if (attempts < 100) {
            positions.push({ left: x, top: y });
          }
        }

        return positions;
      }

      // Генерация точек
      function generateDots() {
        const dotsCountAInput = document.getElementById("dotsCountAInput");
        const dotsCountBInput = document.getElementById("dotsCountBInput");

        CONFIG.dotsCountA = parseInt(dotsCountAInput.value, 10) || 20;
        CONFIG.dotsCountB = parseInt(dotsCountBInput.value, 10) || 20;

        const fieldA = document.getElementById("fieldA");
        const fieldB = document.getElementById("fieldB");

        // Очищаем поля
        fieldA.innerHTML = "";
        fieldB.innerHTML = "";
        initialPositions.clear();

        // Генерируем точки для поля A
        const positionsA = generateRandomPositions(
          fieldA,
          CONFIG.dotsCountA,
          CONFIG.minDistanceA
        );
        positionsA.forEach((pos) => {
          const dot = createDot();
          dot.style.left = `${pos.left}px`;
          dot.style.top = `${pos.top}px`;
          fieldA.appendChild(dot);
          savePosition(dot);
        });

        // Генерируем точки для поля B (в форме кластера с "отлетами")
        const positionsB = generateClusteredPositions(
          fieldB,
          CONFIG.dotsCountB,
          CONFIG.clusterRadius,
          CONFIG.minDistanceB
        );
        positionsB.forEach((pos) => {
          const dot = createDot();
          dot.style.left = `${pos.left}px`;
          dot.style.top = `${pos.top}px`;
          fieldB.appendChild(dot);
          makeDotDraggable(dot);
          savePosition(dot);
        });
      }

      // Создание одной точки
      function createDot() {
        const dot = document.createElement("div");
        dot.className = "dot";
        return dot;
      }

      // Сохранение начальной позиции
      function savePosition(dot) {
        initialPositions.set(dot, {
          top: dot.style.top,
          left: dot.style.left,
        });
      }

      // Включение ручного перетаскивания точек
      function makeDotDraggable(dot) {
        dot.classList.add("draggable");
        dot.addEventListener("mousedown", startDragging);
        dot.addEventListener("touchstart", startDragging, { passive: false });
      }

      function startDragging(event) {
        event.preventDefault();

        const dot = event.target;
        const field = dot.parentElement;

        let shiftX = event.clientX - dot.getBoundingClientRect().left;
        let shiftY = event.clientY - dot.getBoundingClientRect().top;

        function moveAt(pageX, pageY) {
          let newLeft = pageX - shiftX - field.offsetLeft;
          let newTop = pageY - shiftY - field.offsetTop;

          newLeft = Math.max(
            0,
            Math.min(newLeft, field.offsetWidth - dot.offsetWidth)
          );
          newTop = Math.max(
            0,
            Math.min(newTop, field.offsetHeight - dot.offsetHeight)
          );

          dot.style.left = `${newLeft}px`;
          dot.style.top = `${newTop}px`;
        }

        function onMouseMove(event) {
          moveAt(event.pageX, event.pageY);
        }

        document.addEventListener("mousemove", onMouseMove);
        document.addEventListener("mouseup", stopDragging);

        function stopDragging() {
          document.removeEventListener("mousemove", onMouseMove);
          document.removeEventListener("mouseup", stopDragging);
        }
      }

      // Перемешивание точек в блоке B
      function shuffleDots() {
        const fieldB = document.getElementById("fieldB");
        const positionsB = generateClusteredPositions(
          fieldB,
          CONFIG.dotsCountB,
          CONFIG.clusterRadius,
          CONFIG.minDistanceB
        );

        const dots = fieldB.querySelectorAll(".dot");
        dots.forEach((dot, index) => {
          const pos = positionsB[index];
          dot.style.left = `${pos.left}px`;
          dot.style.top = `${pos.top}px`;
          dot.classList.add("shuffle");
          setTimeout(() => dot.classList.remove("shuffle"), 500);
        });
      }

      // Сброс позиций
      function resetPositions() {
        const dots = document.querySelectorAll(".dot");
        dots.forEach((dot) => {
          const initialPos = initialPositions.get(dot);
          if (initialPos) {
            dot.style.top = initialPos.top;
            dot.style.left = initialPos.left;
          }
        });
      }

      // Генерация точек при загрузке страницы
      document.addEventListener("DOMContentLoaded", generateDots);
    </script>
  </body>
</html>
